#!/bin/bash

# Color definitions
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Function to read port from config.json
read_port_from_config() {
  if [ ! -f "config.json" ]; then
    echo "ERROR: config.json not found" >&2
    exit 1
  fi

  local port=$(jq -r '.app.port // 4720' config.json)

  if [[ ! "$port" =~ ^[0-9]+$ ]] || [ "$port" -lt 1024 ] || [ "$port" -gt 65535 ]; then
    echo "ERROR: Invalid port number in config.json: $port" >&2
    echo "Port must be a number between 1024 and 65535" >&2
    exit 1
  fi

  echo "$port"
}

port_number=$(read_port_from_config)

# Check if port is available
check_port_available() {
  local port=$1
  if lsof -Pi :$port -sTCP:LISTEN -t >/dev/null 2>&1 ; then
    return 1  # Port is occupied
  else
    return 0  # Port is available
  fi
}

# Check port availability at startup
if ! check_port_available "$port_number"; then
  echo ""
  echo -e "${RED}ERROR: Port $port_number is already in use!${NC}"
  echo -e "${YELLOW}Please change the port number in config.json${NC}"
  echo -e "${YELLOW}  Edit the 'app.port' field to use a different port${NC}"
  echo ""
  exit 1
fi

YEAR=2026
DATA_PATH="../data"

BANNER="

  ${YELLOW}                                        _        ${NC}
  ${YELLOW}  _____       _         _   _____     _| |_ _    ${NC}
  ${YELLOW} | __  |_ _ _| |___ ___| |_| __  |___|   __| |_  ${NC}
  ${YELLOW} | __ -| | | . | . | -_|  _| __ -| .'|__   |   | ${NC}
  ${YELLOW} |_____|___|___|_  |___|_| |_____|__,|_   _|_|_| ${NC}
  ${YELLOW}               |___|                   |_|       ${NC}

"

main_menu_options=("Initialize Database" "Dashboard Status" "Plot" "Plot Month" "Database Operations" "Settings" "Quit")
main_current_selection=0

settings_menu_options=("Start Backend" "Stop Backend" "Set Demo" "Clean Cache" "Back")
settings_current_selection=0

database_menu_options=("Add Data" "Delete Data" "View Database" "Back")
database_current_selection=0

# Global variables to track menu positions
declare -a MENU_ITEM_ROWS
MENU_START_ROW=0

# Function to draw static parts of main menu (banner + menu structure)
draw_static_main_menu() {
  clear
  tput cup 0 0  # Ensure we start at top-left

  # Get terminal width
  local term_width=$(tput cols)

  # Calculate centering for banner (banner is ~50 chars wide)
  local banner_width=50
  local banner_padding=$(( (term_width - banner_width) / 2 ))

  # Center and display banner (count lines as we go)
  local line_count=0
  echo -e "$BANNER" | while IFS= read -r line; do
    printf "%${banner_padding}s%s\n" "" "$line"
    ((line_count++))
  done

  # Calculate centering for menu items
  local menu_width=40  # Approximate menu width
  local menu_padding=$(( (term_width - menu_width) / 2 ))
  local padding_str=$(printf '%*s' "$menu_padding" "")

  # Print menu header and track the row
  printf "${padding_str}${RED}~~~~ ${NC}${YELLOW}Menu${NC}${RED} ~~~~${NC}\n"

  # Get current cursor row position
  # Banner outputs 10 lines (rows 0-9), menu header is row 10, menu items start at row 11
  local menu_start_row=11

  # Draw all menu items and store their exact row positions
  for i in "${!main_menu_options[@]}"; do
    MENU_ITEM_ROWS[$i]=$((menu_start_row + i))
    if [ $i -eq $main_current_selection ]; then
      printf "${padding_str}${BOLD}${CYAN}▶ ${main_menu_options[$i]}${NC}\n"
    else
      printf "${padding_str}${GREEN}  ${main_menu_options[$i]}${NC}\n"
    fi
  done

  printf "${padding_str}${RED}~~~~~~~~~~~~~~~~~~~~${NC}\n"
  printf "${padding_str}${YELLOW}Use ↑↓ arrows to navigate, Enter to select${NC}\n"
}

# Function to update only the selection indicator (no full redraw)
update_selection_indicator() {
  local old_selection=$1
  local new_selection=$2

  # Get terminal width for centering
  local term_width=$(tput cols)
  local menu_width=40
  local menu_padding=$(( (term_width - menu_width) / 2 ))
  local padding_str=$(printf '%*s' "$menu_padding" "")

  # Clear the old selection indicator (redraw as unselected)
  tput cup ${MENU_ITEM_ROWS[$old_selection]} 0
  printf "\r${padding_str}${GREEN}  ${main_menu_options[$old_selection]}${NC}"
  tput el  # Clear to end of line

  # Draw the new selection indicator
  tput cup ${MENU_ITEM_ROWS[$new_selection]} 0
  printf "\r${padding_str}${BOLD}${CYAN}▶ ${main_menu_options[$new_selection]}${NC}"
  tput el  # Clear to end of line
}

# Function to display the main menu (DEPRECATED - kept for compatibility)
display_main_menu() {
  draw_static_main_menu
}

# Function to read a single keypress
read_key() {
  local key
  IFS= read -rsn1 key
  case $key in
  $'\x1b') # ESC sequence
    IFS= read -rsn2 key
    case $key in
    '[A') echo "UP" ;;
    '[B') echo "DOWN" ;;
    '[C') echo "RIGHT" ;;
    '[D') echo "LEFT" ;;
    *) echo "UNKNOWN" ;;
    esac
    ;;
  '') echo "ENTER" ;;
  'q'|'Q') echo "QUIT" ;;
  *) echo "UNKNOWN" ;;
  esac
}

# Helper function
backend_running() {
  if curl -s localhost:$port_number/ > /dev/null 2>&1; then
    return 0
  else
    return 1
  fi
}

# Helper function
run_if_backend_running() {
  clear
  if backend_running; then
    $1 # execute the command passed as argument
    printf "  ${YELLOW}\nPress any key to continue...${NC}\n"
    read -n 1
  else
    printf "  ${RED}Backend is not running, please start it first...${NC}\n"
    read -n 1
  fi
}

# Function to display the settings submenu
display_settings_menu() {
  clear
  echo -e "  ${RED}~~~~ ${NC}${YELLOW}Settings${NC}${RED} ~~~~${NC}"

  for i in "${!settings_menu_options[@]}"; do
    if [ $i -eq $settings_current_selection ]; then
      echo -e "  ${BOLD}${CYAN}▶ ${settings_menu_options[$i]}${NC}"
    else
      echo -e "  ${GREEN}  ${settings_menu_options[$i]}${NC}"
    fi
  done

  echo -e "  ${RED}~~~~~~~~~~~~~~~~~~~~~~~~${NC}"
  echo -e "  ${YELLOW}Use ↑↓ arrows to navigate, Enter to select${NC}"
}

# Function to display the database operations submenu
display_database_menu() {
  clear
  echo -e "  ${RED}~~~~ ${NC}${YELLOW}Database Operations${NC}${RED} ~~~~${NC}"

  for i in "${!database_menu_options[@]}"; do
    if [ $i -eq $database_current_selection ]; then
      echo -e "  ${BOLD}${CYAN}▶ ${database_menu_options[$i]}${NC}"
    else
      echo -e "  ${GREEN}  ${database_menu_options[$i]}${NC}"
    fi
  done

  echo -e "  ${RED}~~~~~~~~~~~~~~~~~~~~~~~~${NC}"
  echo -e "  ${YELLOW}Use ↑↓ arrows to navigate, Enter to select${NC}"
}


navigate_settings_menu() {
  while true; do
    display_settings_menu
    key=$(read_key)

    case $key in
    "UP")
      if [ $settings_current_selection -gt 0 ]; then
        ((settings_current_selection--))
      else
        settings_current_selection=$((${#settings_menu_options[@]} - 1))
      fi
      ;;
    "DOWN")
      if [ $settings_current_selection -lt $((${#settings_menu_options[@]} - 1)) ]; then
        ((settings_current_selection++))
      else
        settings_current_selection=0
      fi
      ;;
    "ENTER")
      selected_option="${settings_menu_options[$settings_current_selection]}"
      if [ "$selected_option" = "Back" ]; then
        return 0
      elif [ "$selected_option" = "Start Backend" ]; then
        if ! backend_running; then
          clear
          python3 deepbackend.py $port_number &
          printf "  ${YELLOW}Backend started on port $port_number (configured in config.json)${NC}\n"
          printf "  ${GREEN}Press any key to return to main menu.${NC}\n"
          printf "  ${GREEN}Note: this leaves the flask console in background.${NC}\n"
        else
          printf "  ${YELLOW}Backend is already running...${NC}\n"
        fi
        printf "\n  ${YELLOW}Press any key to continue...${NC}\n"
        read -n 1
      elif [ "$selected_option" = "Stop Backend" ]; then
        run_if_backend_running "curl -X GET localhost:$port_number/shutdown"
      elif [ "$selected_option" = "Set Demo" ]; then
        clear
        DATA_PATH="./demo"
        printf "  ${GREEN}Data path set to: $DATA_PATH${NC}\n"
        printf "  ${YELLOW}Press any key to continue...${NC}\n"
        read -n 1
      elif [ "$selected_option" = "Clean Cache" ]; then
        clear
        printf "  ${RED}Warning: This will delete all cached market data files${NC}\n"
        printf "  ${YELLOW}Cache location: ./demo/cache/${NC}\n"
        printf "  ${YELLOW}Files will be re-downloaded when needed${NC}\n\n"
        printf "  ${BOLD}Are you sure? (y/N): ${NC}"
        read -n 1 confirm
        echo
        if [[ "$confirm" =~ ^[Yy]$ ]]; then
          if [ -d "./demo/cache" ]; then
            # Count files before deletion (excluding .gitignore)
            file_count=$(find ./demo/cache -type f ! -name '.gitignore' | wc -l)
            if [ "$file_count" -gt 0 ]; then
              # Delete all files except .gitignore
              find ./demo/cache -type f ! -name '.gitignore' -delete
              printf "\n  ${GREEN}✓ Successfully deleted $file_count cache file(s)${NC}\n"
            else
              printf "\n  ${YELLOW}Cache is already empty${NC}\n"
            fi
          else
            printf "\n  ${RED}Error: Cache directory not found${NC}\n"
          fi
        else
          printf "\n  ${YELLOW}Cache cleanup cancelled${NC}\n"
        fi
        printf "  ${YELLOW}Press any key to continue...${NC}\n"
        read -n 1
      fi
      ;;
    esac
  done
}

navigate_database_menu() {
  # Source database functions
  source ./db_add
  source ./db_delete
  
  while true; do
    display_database_menu
    key=$(read_key)

    case $key in
    "UP")
      if [ $database_current_selection -gt 0 ]; then
        ((database_current_selection--))
      else
        database_current_selection=$((${#database_menu_options[@]} - 1))
      fi
      ;;
    "DOWN")
      if [ $database_current_selection -lt $((${#database_menu_options[@]} - 1)) ]; then
        ((database_current_selection++))
      else
        database_current_selection=0
      fi
      ;;
    "ENTER")
      selected_option="${database_menu_options[$database_current_selection]}"
      if [ "$selected_option" = "Back" ]; then
        return 0
      elif [ "$selected_option" = "Add Data" ]; then
        run_if_backend_running "add_data $port_number"
      elif [ "$selected_option" = "Delete Data" ]; then
        run_if_backend_running "delete_data $port_number"
      elif [ "$selected_option" = "View Database" ]; then
        view_database_interactive
      fi
      ;;
    esac
  done
}

view_database_interactive() {
  if ! backend_running; then
    clear
    printf "  ${RED}Backend is not running. Please start it first.${NC}\n"
    printf "  ${YELLOW}Press any key to continue...${NC}\n"
    read -n 1
    return
  fi
  
  # Default values
  local data_types=("cashflow" "investments")
  local current_data_type_index=0
  local data_type="${data_types[$current_data_type_index]}"
  
  # Get current year and month
  local current_year=$(date +%Y)
  local current_month=$(date +%m | sed 's/^0//')  # Remove leading zero
  local years=("2023" "2024" "2025" "2026" "2027")
  local current_year_index=3  # Default to 2026, adjust if needed
  for i in "${!years[@]}"; do
    if [ "${years[$i]}" = "$current_year" ]; then
      current_year_index=$i
      break
    fi
  done
  local year="${years[$current_year_index]}"
  
  local months=("1" "2" "3" "4" "5" "6" "7" "8" "9" "10" "11" "12")
  local month_names=("January" "February" "March" "April" "May" "June" "July" "August" "September" "October" "November" "December")
  local current_month_index=$((current_month - 1))
  local month="${months[$current_month_index]}"
  
  local current_field=1  # 1=data_type, 2=year, 3=month
  
  # Function to fetch and display database
  fetch_and_display() {
    local dt="$1"
    local yr="$2"
    local mo="$3"
    local response=$(curl -s "localhost:$port_number/view_database?data_type=${dt}&year=${yr}&month=${mo}")
    
    clear
    printf "  ${YELLOW}View Database${NC}\n"
    printf "  ${CYAN}=============${NC}\n\n"
    
    # Display selection fields
    if [ $current_field -eq 1 ]; then
      printf "  ${BOLD}${CYAN}▶ Data Type: ${data_type}${NC}\n"
    else
      printf "  ${GREEN}  Data Type: ${data_type}${NC}\n"
    fi
    
    if [ $current_field -eq 2 ]; then
      printf "  ${BOLD}${CYAN}▶ Year: ${year}${NC}\n"
    else
      printf "  ${GREEN}  Year: ${year}${NC}\n"
    fi
    
    if [ $current_field -eq 3 ]; then
      printf "  ${BOLD}${CYAN}▶ Month: ${month_names[$current_month_index]} (${month})${NC}\n"
    else
      printf "  ${GREEN}  Month: ${month_names[$current_month_index]} (${month})${NC}\n"
    fi
    
    printf "\n  ${YELLOW}Use ↑↓ to navigate fields, ←→ to change values, 'q' to quit${NC}\n"
    printf "  ${RED}────────────────────────────────────────────────${NC}\n\n"
    
    # Display table
    if echo "$response" | grep -q "Error"; then
      printf "  ${RED}${response}${NC}\n"
    else
      echo -e "${response}"
    fi
  }
  
  # Initial display
  fetch_and_display "$data_type" "$year" "$month"
  
  while true; do
    key=$(read_key)
    
    case $key in
      "UP")
        if [ $current_field -gt 1 ]; then
          ((current_field--))
        else
          current_field=3
        fi
        fetch_and_display "$data_type" "$year" "$month"
        ;;
      "DOWN")
        if [ $current_field -lt 3 ]; then
          ((current_field++))
        else
          current_field=1
        fi
        fetch_and_display "$data_type" "$year" "$month"
        ;;
      "LEFT")
        case $current_field in
          1) # Data type
            if [ $current_data_type_index -gt 0 ]; then
              ((current_data_type_index--))
              data_type="${data_types[$current_data_type_index]}"
              fetch_and_display "$data_type" "$year" "$month"
            fi
            ;;
          2) # Year
            if [ $current_year_index -gt 0 ]; then
              ((current_year_index--))
              year="${years[$current_year_index]}"
              fetch_and_display "$data_type" "$year" "$month"
            fi
            ;;
          3) # Month
            if [ $current_month_index -gt 0 ]; then
              ((current_month_index--))
              month="${months[$current_month_index]}"
              fetch_and_display "$data_type" "$year" "$month"
            fi
            ;;
        esac
        ;;
      "RIGHT")
        case $current_field in
          1) # Data type
            if [ $current_data_type_index -lt $((${#data_types[@]} - 1)) ]; then
              ((current_data_type_index++))
              data_type="${data_types[$current_data_type_index]}"
              fetch_and_display "$data_type" "$year" "$month"
            fi
            ;;
          2) # Year
            if [ $current_year_index -lt $((${#years[@]} - 1)) ]; then
              ((current_year_index++))
              year="${years[$current_year_index]}"
              fetch_and_display "$data_type" "$year" "$month"
            fi
            ;;
          3) # Month
            if [ $current_month_index -lt $((${#months[@]} - 1)) ]; then
              ((current_month_index++))
              month="${months[$current_month_index]}"
              fetch_and_display "$data_type" "$year" "$month"
            fi
            ;;
        esac
        ;;
      "QUIT")
        return
        ;;
    esac
  done
}

display_dashboard() {
    clear
    
    # Fetch JSON data
    local response=$(curl -s localhost:$port_number/dashboard_status)
    # Check if response contains error
    local status=$(echo "$response" | jq -r '.status' 2>/dev/null)
    if [ "$status" = "error" ]; then
        local error_msg=$(echo "$response" | jq -r '.message' 2>/dev/null)
        printf "  ${RED}Error: %s${NC}\n" "$error_msg"
        printf "  ${YELLOW}Make sure the database is initialized first.${NC}\n"
        printf "\n  ${YELLOW}Press any key to continue...${NC}\n"
        read -n 1
        return 1
    fi
    
    # Extract values using jq
    local liquidity=$(echo "$response" | jq -r '.liquidity')
    local investments=$(echo "$response" | jq -r '.investments')
    local networth=$(echo "$response" | jq -r '.networth')
    local nwch=$(echo "$response" | jq -r '.nwch')
    local pct_ch=$(echo "$response" | jq -r '.pct_ch')

    # Extract account balances as key-value pairs
    local balances_json=$(echo "$response" | jq -r '.all_balances // {}')
    
    # Format numbers (remove .00 if present)
    local networth_str=$(printf "%.2f" "$networth" | sed 's/\.00$//')
    local liquidity_str=$(printf "%.2f" "$liquidity" | sed 's/\.00$//')
    local investments_str=$(printf "%.2f" "$investments" | sed 's/\.00$//')
    local nwch_str=$(printf "%.2f" "$nwch" | sed 's/\.00$//')
    local pct_ch_str=$(printf "%.2f" "$pct_ch" | sed 's/\.00$//')
    
    # Find the longest label to determine center alignment
    local max_label_len=20  # "Percentage Change: " is the longest
    
    # Create dashboard with centered layout
    printf "  ${RED}┌─ BudgetBash Dashboard ──────────────────┐${NC}\n"
    printf "\n"
    printf "  ${YELLOW}Net Worth:${NC} ${GREEN}€%s${NC}\n" "$networth_str"
    printf "  ${YELLOW}Liquidity:${NC} ${BLUE}€%s${NC}\n" "$liquidity_str"
    printf "  ${YELLOW}Investments:${NC} ${CYAN}€%s${NC}\n" "$investments_str"
    printf "  ${YELLOW}Net Worth Change:${NC} ${CYAN}€%s${NC}\n" "$nwch_str"
    printf "  ${YELLOW}Percentage Change:${NC} ${CYAN}%s%%${NC}\n" "$pct_ch_str"
    printf "\n"
    printf "  ${RED}└────────────────────────────────────────┘${NC}\n"

    # Display Account Cards box
    printf "\n"
    printf "  ${RED}┌─ Account Cards ─────────────────────────┐${NC}\n"
    printf "\n"

    # Check if balances exist
    if [ "$balances_json" != "{}" ] && [ "$balances_json" != "null" ]; then
        # Get all account names and sort them
        local account_names=$(echo "$balances_json" | jq -r 'keys[]' 2>/dev/null | sort)

        # Display each account balance
        if [ -n "$account_names" ]; then
            while IFS= read -r account; do
                local balance=$(echo "$balances_json" | jq -r --arg acc "$account" '.[$acc]' 2>/dev/null)

                # Format balance (remove .00 if present)
                local balance_str=$(printf "%.2f" "$balance" 2>/dev/null | sed 's/\.00$//')

                # Handle potential formatting errors
                if [ $? -ne 0 ] || [ -z "$balance_str" ]; then
                    balance_str="0"
                fi

                # Display with consistent color (CYAN for all balances)
                printf "  ${YELLOW}%s:${NC} ${CYAN}€%s${NC}\n" "$account" "$balance_str"
            done <<< "$account_names"
        else
            printf "  ${YELLOW}No accounts found${NC}\n"
        fi
    else
        printf "  ${YELLOW}No account data available${NC}\n"
    fi

    printf "\n"
    printf "  ${RED}└────────────────────────────────────────┘${NC}\n"

    printf "\n  ${YELLOW}Press any key to continue...${NC}\n"
    read -n 1
}

display_plots() {
  clear

  # Fetch plots made with plotext for terminal
  curl -X GET "localhost:$port_number/plot" > /dev/null 2>&1

  printf "\n  ${YELLOW}Press any key to continue...${NC}\n"
  read -n 1
}

plot_month_interactive() {
  if ! backend_running; then
    clear
    printf "  ${RED}Backend is not running. Please start it first.${NC}\n"
    printf "  ${YELLOW}Press any key to continue...${NC}\n"
    read -n 1
    return
  fi

  local current_month=$(date +%m | sed 's/^0//')
  local months=("1" "2" "3" "4" "5" "6" "7" "8" "9" "10" "11" "12")
  local month_names=("January" "February" "March" "April" "May" "June" "July" "August" "September" "October" "November" "December")
  local current_month_index=$((current_month - 1))
  local month="${months[$current_month_index]}"
  
  local categories=()
  local current_category_index=0
  local category=""

  # Function to load categories for a specific month
  load_categories() {
    local mo="$1"
    
    local response=$(curl -s "localhost:$port_number/get_expenses_categories?month=${mo}")
    
    if command -v jq &> /dev/null; then
      readarray -t categories < <(echo "$response" | jq -r '.categories[]')
    else
      # Fallback parsing
      local cats_string=$(echo "$response" | sed 's/.*"categories":\s*\[//;s/\].*//')
      IFS=',' read -ra temp_cats <<< "$cats_string"
      categories=()
      for cat in "${temp_cats[@]}"; do
        cat=$(echo "$cat" | sed 's/^[[:space:]]*"//;s/"[[:space:]]*$//' | tr -d '\n\r')
        if [ -n "$cat" ]; then
          categories+=("$cat")
        fi
      done
    fi
    
    # Start with first category
    if [ ${#categories[@]} -gt 0 ]; then
      current_category_index=0
      category="${categories[$current_category_index]}"
    else
      category=""
      categories=()
    fi
  }

  display_month_plot() {
    local mo="$1"
    local mo_idx="$2"
    local cat="$3"
    local cat_idx="$4"
    
    clear
    printf "  ${YELLOW}Monthly Expenses Plot - ${month_names[$mo_idx]} (${mo})${NC}\n"
    printf "  ${CYAN}================================================${NC}\n\n"
    
    if [ -z "$cat" ]; then
      printf "  ${YELLOW}No data available for this month${NC}\n"
      printf "\n  ${YELLOW}Use ←→ to change month, 'q' to quit${NC}\n"
      return
    fi
    
    local encoded_cat="${cat// /%20}"
    curl -s "localhost:$port_number/plot_month?month=${mo}&category=${encoded_cat}"
    printf "  ${CYAN}Category: ${cat} [${cat_idx}/${#categories[@]}]${NC}\n"

    printf "\n  ${YELLOW}Use ←→ to change month, ↑↓ to change category, 'q' to quit${NC}\n"
  }

  # Initial load
  load_categories "$month"
  display_month_plot "$month" "$current_month_index" "$category" "$((current_category_index + 1))"

  while true; do
    key=$(read_key)
    
    case $key in
      "LEFT")
        if [ $current_month_index -gt 0 ]; then
          ((current_month_index--))
          month="${months[$current_month_index]}"
          load_categories "$month"
          display_month_plot "$month" "$current_month_index" "$category" "$((current_category_index + 1))"
        fi
        ;;
      "RIGHT")
        if [ $current_month_index -lt $((${#months[@]} - 1)) ]; then
          ((current_month_index++))
          month="${months[$current_month_index]}"
          load_categories "$month"
          display_month_plot "$month" "$current_month_index" "$category" "$((current_category_index + 1))"
        fi
        ;;
      "UP")
        if [ ${#categories[@]} -gt 0 ] && [ $current_category_index -gt 0 ]; then
          ((current_category_index--))
          category="${categories[$current_category_index]}"
          display_month_plot "$month" "$current_month_index" "$category" "$((current_category_index + 1))"
        fi
        ;;
      "DOWN")
        if [ ${#categories[@]} -gt 0 ] && [ $current_category_index -lt $((${#categories[@]} - 1)) ]; then
          ((current_category_index++))
          category="${categories[$current_category_index]}"
          display_month_plot "$month" "$current_month_index" "$category" "$((current_category_index + 1))"
        fi
        ;;
      "QUIT")
        return
        ;;
    esac
  done
}

# Function to handle main menu navigation
navigate_main_menu() {
  # Enter alternate screen buffer for clean display
  tput smcup

  # Hide cursor for cleaner appearance
  tput civis

  # Trap to ensure cleanup on exit
  trap 'tput rmcup; tput cnorm' EXIT INT TERM

  # Draw the static menu once
  draw_static_main_menu

  while true; do
    key=$(read_key)

    # Store old selection for selective update
    old_selection=$main_current_selection

    case $key in
    "UP")
      if [ $main_current_selection -gt 0 ]; then
        ((main_current_selection--))
      else
        main_current_selection=$((${#main_menu_options[@]} - 1))
      fi
      # Only update the changed lines
      update_selection_indicator $old_selection $main_current_selection
      ;;
    "DOWN")
      if [ $main_current_selection -lt $((${#main_menu_options[@]} - 1)) ]; then
        ((main_current_selection++))
      else
        main_current_selection=0
      fi
      # Only update the changed lines
      update_selection_indicator $old_selection $main_current_selection
      ;;
    "ENTER")
      selected_option="${main_menu_options[$main_current_selection]}"

      # Exit alternate screen and show cursor for menu actions
      tput rmcup
      tput cnorm

      if [ "$selected_option" = "Initialize Database" ]; then
        clear
        if ! backend_running; then
          printf "  ${RED}Backend is not running. Please start it from Settings first.${NC}\n"
          printf "  ${YELLOW}Press any key to continue...${NC}\n"
          read -n 1
        else
          printf "  ${YELLOW}Enter year (e.g., 2025, current: $YEAR): ${NC}"
          read -r input_year
          if [ -n "$input_year" ]; then
            YEAR=$input_year
          fi

          printf "  ${YELLOW}Enter data path (e.g., ./demo or ../data, current: $DATA_PATH): ${NC}"
          read -r input_path
          if [ -n "$input_path" ]; then
            DATA_PATH=$input_path
          fi

          response=$(curl -s -X POST "localhost:$port_number/initialize" \
            -d "year=$YEAR&data_path=$DATA_PATH")

          if echo "$response" | grep -q "Error"; then
            printf "\n  ${RED}%s${NC}\n" "$response"
          else
            printf "\n  ${GREEN}%s${NC}\n" "$response"
          fi
          printf "  ${YELLOW}Press any key to continue...${NC}\n"
          read -n 1
        fi
      elif [ "$selected_option" = "Dashboard Status" ]; then
        if ! backend_running; then
          clear
          printf "  ${RED}Backend is not running. Please start it from Settings first.${NC}\n"
          printf "  ${YELLOW}Press any key to continue...${NC}\n"
          read -n 1
        else
          display_dashboard
        fi
      elif [ "$selected_option" = "Plot" ]; then
        if ! backend_running; then
          clear
          printf "  ${RED}Backend is not running. Please start it from Settings first.${NC}\n"
          printf "  ${YELLOW}Press any key to continue...${NC}\n"
          read -n 1
        else
          display_plots
        fi
      elif [ "$selected_option" = "Plot Month" ]; then
        if ! backend_running; then
          clear
          printf "  ${RED}Backend is not running. Please start it from Settings first.${NC}\n"
          printf "  ${YELLOW}Press any key to continue...${NC}\n"
          read -n 1
        else
          plot_month_interactive
        fi
      elif [ "$selected_option" = "Database Operations" ]; then
        navigate_database_menu
      elif [ "$selected_option" = "Settings" ]; then
        navigate_settings_menu
      elif [ "$selected_option" = "Quit" ]; then
        if backend_running; then
          curl -X GET "localhost:$port_number/shutdown" > /dev/null 2>&1
          printf "  ${YELLOW}Backend stopped...${NC}\n"
        fi
        printf "  ${BLUE}Goodbye!${NC}\n"
        exit 0
      fi

      # Re-enter alternate screen and hide cursor after action
      tput smcup
      tput civis
      draw_static_main_menu
      ;;
    "QUIT")
      # Clean exit
      tput rmcup
      tput cnorm
      if backend_running; then
        curl -X GET "localhost:$port_number/shutdown" > /dev/null 2>&1
        printf "  ${YELLOW}Backend stopped...${NC}\n"
      fi
      printf "  ${BLUE}Goodbye!${NC}\n"
      exit 0
      ;;
    esac
  done
}

navigate_main_menu
